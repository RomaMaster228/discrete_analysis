\section{Тест производительности}
{\itshape}

Тест производительности представляет из себя следующее: поразрядная сортировка сравнивается с $std::stable\_sort$. Время на ввод данных не учитывается. Количество пар \enquote{ключ-значение} для каждого файла равно десять в степени номер теста минус один. Например, $02.t$ содержит десять пар, а $07.t$ миллион.

\begin{alltt}
roma@DESKTOP-JD58QU2:~/Diskran/lab1$ ./benchmark < tests/04.t > 04.a
radix sort 6 ms
stable sort from std 0 ms
roma@DESKTOP-JD58QU2:~/Diskran/lab1$ ./benchmark < tests/05.t > 05.a
radix sort 9 ms
stable sort from std 6 ms
roma@DESKTOP-JD58QU2:~/Diskran/lab1$ ./benchmark < tests/06.t > 06.a
radix sort 37 ms
stable sort from std 168 ms
roma@DESKTOP-JD58QU2:~/Diskran/lab1$ ./benchmark < tests/07.t > 07.a
radix sort 478 ms
stable sort from std 2371 ms
\end{alltt}

Глядя на результаты, видно, что $std::stable\_sort$ выигрывает больше всего на самых маленьких тестах, а $RadixSort$ на самых больших. Сложность $std::stable\_sort$ $O(n * log\ n)$, а сложность $RadixSort$ $O(m * n)$, где $m$ - количество разрядов в числе. Так как логарифм является возрастающей функцией, переломный момент наступает, когда $log\ n$ становится больше, чем постоянная $m$.

\pagebreak

